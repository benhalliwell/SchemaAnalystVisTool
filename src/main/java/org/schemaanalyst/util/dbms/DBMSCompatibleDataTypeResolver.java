package org.schemaanalyst.util.dbms;

import org.schemaanalyst.configuration.DatabaseConfiguration;
import org.schemaanalyst.configuration.LocationsConfiguration;
import org.schemaanalyst.dbms.DBMS;
import org.schemaanalyst.dbms.DatabaseInteractor;
import org.schemaanalyst.dbms.hypersql.HyperSQLDBMS;
import org.schemaanalyst.dbms.postgres.PostgresDBMS;
import org.schemaanalyst.dbms.sqlite.SQLiteDBMS;
import org.schemaanalyst.sqlrepresentation.Column;
import org.schemaanalyst.sqlrepresentation.Schema;
import org.schemaanalyst.sqlrepresentation.Table;
import org.schemaanalyst.sqlrepresentation.datatype.*;
import org.schemaanalyst.sqlwriter.SQLWriter;
import org.schemaanalyst.testgeneration.TestCaseExecutionException;

import java.text.SimpleDateFormat;
import java.util.*;

/**
 * Created by phil on 21/07/2015.
 */
public class DBMSCompatibleDataTypeResolver {

    private static final String DB_NAME = "compatible_types_testing";

    private List<DataType> dataTypeList;

    private DBMS dbms;
    private DatabaseInteractor databaseInteractor;
    private SQLWriter sqlWriter;

    public DBMSCompatibleDataTypeResolver() {
        initializeDataTypeList();
    }

    public void writeCompatibleDataTypes(DBMS dbms) {
        this.dbms = dbms;

        databaseInteractor = dbms.getDatabaseInteractor(
                DB_NAME,
                new DatabaseConfiguration(),
                new LocationsConfiguration());

        sqlWriter = dbms.getSQLWriter();

        Map<DataType, Set<DataType>> compatibleTypes = getCompatibleDataTypes();

        outputHeader();
        System.out.println("\t\tcompatibleTypes = new HashMap<>();");
        for (DataType sourceType : dataTypeList) {
            Set<DataType> targetTypes = compatibleTypes.get(sourceType);

            if (targetTypes.size() > 0) {
                System.out.println("\t\tcompatibleTypes.put(" + getClassString(sourceType) +
                        ", new HashSet<Class<?>>());");


                // produce a sorted list
                List<DataType> targetTypesList = new ArrayList<>();
                targetTypesList.addAll(targetTypes);
                Collections.sort(targetTypesList, new Comparator<DataType>() {
                    @Override
                    public int compare(DataType o1, DataType o2) {
                        return o1.getClass().toString().compareTo(o2.getClass().toString());
                    }
                });

                for (DataType targetType : targetTypesList) {
                    System.out.println(
                            "\t\tcompatibleTypes.get(" + getClassString(sourceType) +
                                    ").add(" + getClassString(targetType) + ");");
                }
            }
        }
        outputFooter();
    }

    private void outputHeader() {
        long currentTime = System.currentTimeMillis();
        SimpleDateFormat sdf = new SimpleDateFormat("MMM dd,yyyy HH:mm");
        Date resultDate = new Date(currentTime);
        String timeString = sdf.format(resultDate);

        System.out.println("\t/*");
        System.out.println("\t  Automatically generated by " + this.getClass());
        System.out.println("\t for " + dbms.getClass().getSimpleName() + " on " + timeString + "\n");

        System.out.println("\t  Map<Class<?>, Set<Class<?>>> compatibleTypes;");
        System.out.println("\t*/");

        System.out.println("\tprotected void initializeCompatibleTypes() {");
    }

    private void outputFooter() {
        System.out.println("\t}");
    }

    private String getClassString(DataType type) {
        return type.getClass().getSimpleName() + ".class";
    }

    private Map<DataType, Set<DataType>> getCompatibleDataTypes() {
        Map<DataType, Set<DataType>> compatibleDataTypes = new HashMap<>();

        for (DataType type : dataTypeList) {
            compatibleDataTypes.put(type, new HashSet<DataType>());
        }

        for (DataType type : dataTypeList) {
            for (DataType referenceType : dataTypeList) {
                boolean result = checkType(type, referenceType);

                if (result) {
                    compatibleDataTypes.get(type).add(referenceType);
                }
            }
        }

        return compatibleDataTypes;
    }

    private boolean checkType(DataType type, DataType referenceType) {
        Schema schema = makeSchema(type, referenceType);

        dropTablesIfExist(schema);

        List<String> createStatements = sqlWriter.writeCreateTableStatements(schema);
        if (createStatements.size() != 2) {
            throw new RuntimeException("Exactly two CREATE TABLE statements should have been generated");
        }

        String statement1 = createStatements.get(0);
        Integer result1 = databaseInteractor.executeUpdate(statement1);
        if (result1 < 0) {
            throw new TestCaseExecutionException(
                    "Could not execute CREATE TABLE statement \"" + statement1 +
                            "\" while executing statement 1, result was " + result1);
        }

        String statement2 = createStatements.get(1);
        Integer result2 = databaseInteractor.executeUpdate(statement2);

        boolean result = (result2 >= 0);

        return result;
    }

    private void dropTablesIfExist(Schema schema) {
        List<String> dropTableStatements = sqlWriter.writeDropTableStatements(schema, true);
        for (String statement : dropTableStatements) {
            Integer result = databaseInteractor.executeUpdate(statement);
            if (result < 0) {
                throw new RuntimeException(
                        "Problem while executing DROP TABLE statement \"" + statement + "\", result was " + result);
            }
        }
    }

    private Schema makeSchema(DataType sourceType, DataType targetType) {
        Schema schema = new Schema(DB_NAME);
        Table table = schema.createTable("table");
        Table referenceTable = schema.createTable("referenceTable");
        Column column = table.createColumn("column", sourceType);
        Column referenceColumn = referenceTable.createColumn("referenceColumn", targetType);
        schema.createPrimaryKeyConstraint(table, column);
        schema.createPrimaryKeyConstraint(referenceTable, referenceColumn);
        schema.createForeignKeyConstraint(table, column, referenceTable, referenceColumn);
        return schema;
    }

    private void initializeDataTypeList() {
        dataTypeList = new ArrayList<>();
        dataTypeList.add(new BigIntDataType());
        dataTypeList.add(new BooleanDataType());
        dataTypeList.add(new CharDataType());
        dataTypeList.add(new DateDataType());
        dataTypeList.add(new DateTimeDataType());
        dataTypeList.add(new DecimalDataType());
        dataTypeList.add(new DoubleDataType());
        dataTypeList.add(new FloatDataType());
        dataTypeList.add(new IntDataType());
        dataTypeList.add(new MediumIntDataType());
        dataTypeList.add(new NumericDataType());
        dataTypeList.add(new RealDataType());
        dataTypeList.add(new SingleCharDataType());
        dataTypeList.add(new SmallIntDataType());
        dataTypeList.add(new TextDataType());
        dataTypeList.add(new TimeDataType());
        dataTypeList.add(new TimestampDataType());
        dataTypeList.add(new TinyIntDataType());
        dataTypeList.add(new VarCharDataType());
    }

    public static void main(String[] args) {
        // DBMS dbms = new HyperSQLDBMS();
        // DBMS dbms = new PostgresDBMS();
        DBMS dbms = new SQLiteDBMS();
        DBMSCompatibleDataTypeResolver cdt = new DBMSCompatibleDataTypeResolver();
        cdt.writeCompatibleDataTypes(dbms);
    }
}
